import ApproveAndCallFallBack as ApproveAndCallFallBackInterface

implements: ApproveAndCallFallBackInterface

struct Data:
    developer: address
    id: bytes32
    dappBalance: uint256
    rate: uint256
    available: uint256
    v_minted: uint256
    v_cast: uint256
    e_balance: uint256

contract ERC20:
    def totalSupply() -> uint256: constant
    def balanceOf(_owner: address) -> uint256: constant
    def allowance(_owner: address, _spender: address) -> uint256: constant
    def transfer(_to: address, _value: uint256) -> bool: modifying
    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: modifying
    def approve(_spender: address, _value: uint256) -> bool: modifying

# Events
DAppCreated: event({_id: bytes32, _amount: uint256})
Upvote: event({_id: bytes32, _amount: uint256, _newEffectiveBalance: uint256})
Downvote: event({_id: bytes32, _cost: uint256, _newEffectiveBalance: uint256})
Withdraw: event({_id: bytes32, _amount: uint256, _newEffectiveBalance: uint256})

TOTAL_SNT: constant(uint256) = 3470483788

dapps: map(uint256, Data)
idToIdx: map(bytes32, uint256)
currMax: public(uint256)

total: public(uint256)
ceiling: public(uint256)
maxStake: public(uint256)

SNT: ERC20

#Constant functions
@public
@constant
def upvoteEffect(_id: bytes32, _amount: uint256) -> uint256:
    dappIdx: uint256 = self.idToIdx[_id]
    dapp: Data = self.dapps[dappIdx]

    assert dapp.id == _id

    mBalance: uint256 = dapp.dappBalance + _amount
    mRate: uint256 = 1 - (mBalance / self.maxStake)
    mAvailable: uint256 = mBalance * mRate
    mVMinted: uint256 = mAvailable ** (1 / mRate)
    mEBalance: uint256 = mBalance - ((mVMinted * mRate) * (mAvailable / mVMinted))

    return (mEBalance - dapp.dappBalance)

@public
def downvoteCost(_id: bytes32, _percentDown: uint256) -> uint256[3]:
    dappIdx: uint256 = self.idToIdx[_id]
    dapp: Data = self.dapps[dappIdx]

    assert dapp.id == _id

    balanceDownBy: uint256 = (_percentDown * dapp.e_balance) / 100
    votesRequired: uint256 = (balanceDownBy * dapp.v_minted * dapp.rate) / dapp.available
    cost: uint256 = (dapp.available / (dapp.v_minted - (dapp.v_cast + votesRequired))) * (votesRequired / _percentDown / 10000)

    return [balanceDownBy, votesRequired, cost]

#Constructor
@public
def __init__(_tokenAddr: address):
    self.SNT = ERC20(_tokenAddr)
    self.total = TOTAL_SNT
    self.ceiling = 40
    self.maxStake = (self.total * self.ceiling) / 10000

#Private Functions
@public 
def _createDapp(_from: address, _id: bytes32, _amount: uint256):
    assert _amount > 0
    assert _amount < self.total
    assert self.SNT.allowance(_from, self) >= _amount
    assert self.SNT.transferFrom(_from, self, _amount)

    self.idToIdx[_id] = self.currMax
    newDapp: Data

    newDapp.developer = _from
    newDapp.id = _id
    newDapp.dappBalance = _amount 
    newDapp.rate = 1 - (newDapp.dappBalance / self.maxStake) 
    newDapp.available = newDapp.dappBalance * newDapp.rate
    newDapp.v_minted = newDapp.available ** (1 / newDapp.rate)
    newDapp.v_cast = 0
    newDapp.e_balance = newDapp.dappBalance - ((newDapp.v_cast * newDapp.rate) * (newDapp.available / newDapp.v_minted))

    self.dapps[self.currMax] = newDapp
    self.currMax += 1

    log.DAppCreated(_id, newDapp.e_balance)

@private
def _upvote(_from: address, _id: bytes32, _amount: uint256):
    assert _amount > 0

    dappIdx: uint256 = self.idToIdx[_id]
    dapp: Data = self.dapps[dappIdx]

    assert dapp.id == _id
    assert dapp.dappBalance + _amount < self.maxStake
    assert self.SNT.allowance(_from, self) >= _amount
    assert self.SNT.transferFrom(_from, self, _amount)

    dapp.dappBalance += _amount
    dapp.rate = 1 - (dapp.dappBalance / self.maxStake)
    dapp.available = dapp.dappBalance * dapp.rate
    dapp.v_minted = dapp.available ** (1 / dapp.rate)
    dapp.e_balance = dapp.dappBalance - ((dapp.v_cast * dapp.rate) * (dapp.available / dapp.v_minted))

    self.dapps[dappIdx] = dapp

    log.Upvote(_id, _amount, dapp.e_balance)

@private
def _downvote(_from: address, _id: bytes32, _percentDown: uint256):
    assert _percentDown >= 500 and _percentDown <= 500

    dappIdx: uint256 = self.idToIdx[_id]
    dapp: Data = self.dapps[dappIdx]

    assert dapp.id == _id

    downvoteEffect: uint256[3] = self.downvoteCost(_id, _percentDown)

    assert self.SNT.allowance(_from, dapp.developer) >= downvoteEffect[2]
    assert self.SNT.transferFrom(_from, dapp.developer, downvoteEffect[2])

    dapp.available -= downvoteEffect[2]
    dapp.v_cast += downvoteEffect[1]
    dapp.e_balance -= downvoteEffect[0]

    self.dapps[dappIdx] = dapp

    log.Downvote(_id, downvoteEffect[2], dapp.e_balance)

@private
def decodeSignature(_data: bytes[132]) -> bytes[4]:
    return slice(_data, start=0, len=4)

@private
def decodeId(_data: bytes[132]) -> bytes32:
    return extract32(_data, 4, type=bytes32)

@private
def decodeAmount(_data: bytes[132]) -> uint256:
    return convert(extract32(_data, 32, type=bytes32), uint256)

# Public Functions
@public 
def createDapp(_id: bytes32, _amount: uint256):
    self._createDapp(msg.sender, _id, _amount)

@public
def upvote(_id: bytes32, _amount: uint256):
    self._upvote(msg.sender, _id, _amount)

@public
def downvote(_id: bytes32, _percentDown: uint256):
    self._downvote(msg.sender, _id, _percentDown)

@public
def withdraw(_id: bytes32, _amount: uint256):
    dappIdx: uint256 = self.idToIdx[_id]
    dapp: Data = self.dapps[dappIdx]

    assert dapp.id == _id
    assert msg.sender == dapp.developer
    assert _amount <= dapp.available

    dapp.dappBalance -= _amount
    dapp.rate = 1 - (dapp.dappBalance / self.maxStake)
    dapp.available = dapp.dappBalance * dapp.rate
    dapp.v_minted = dapp.available ** (1 / dapp.rate)
    if (dapp.v_cast > dapp.v_minted):
        dapp.v_cast = dapp.v_minted
    dapp.e_balance = dapp.dappBalance - ((dapp.v_cast * dapp.rate) * (dapp.available / dapp.v_minted))

    self.dapps[dappIdx] = dapp
    assert self.SNT.transferFrom(self, dapp.developer, _amount)

    log.Withdraw(_id, _amount, dapp.e_balance)

@public
def receiveApproval(_from: address, _amount: uint256, _token: address, _data: bytes[132]):
    assert _token == msg.sender
    assert _token == self

    sig: bytes[4] = self.decodeSignature(_data)
    id: bytes32 = self.decodeId(_data)
    amount: uint256 = self.decodeAmount(_data)

    assert amount == _amount

    if (sig == b"\x1a\x21\x4f\x43"):
        self._createDapp(_from, id, amount)
    elif (sig == b"\xac\x76\x90\x90"):
        self._downvote(_from, id, amount)
    elif (sig == b"\x2b\x3d\xf6\x90"):
        self._upvote(_from, id, amount)
    else:
        assert False

@public
def updateCeiling(_newCeiling: uint256):
    #TO-DO:??
    pass
